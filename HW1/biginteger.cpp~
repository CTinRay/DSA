#include "biginteger.h"
#include <algorithm>

BigInteger::BigInteger(){
	nSets = 0;
	sign = ZERO;
}

BigInteger::BigInteger(const int&initial){
	if( initial > 0 ){
		sign = ZERO;
	}else if( initial < 0 ){
		sign = NEGATIVE;
		initial = -initial;
	}else{
		sign = 0;
	}
	nSets = 2;
	numberSets[ 1 ] = initial >> expo2;
	numberSets[ 0 ] = initial & setMask;
}

BigInteger::BigInteger(const std::string&numStr){
	int strLen = numStr.length();
	int offset = strLen % expo10;
	int n10Sets = strLen / expo10;
	Int sets10[ nDigit / expo10 + 1 ];
	string strTmp = numStr.substr( 0 , offset );
	sets10[ n10Sets - 1 ] = stoi( strTmp , 0 , 10 );	
	for( int i = 1 ; i < n10Sets + 1 ; ++i ){
		strTmp = numStr.substr( i * expo10 + offset , (i+1) * expo10 + offset );
		sets10[ n10Sets - i ] = stoi( strTmp , 0 , 10 );
	}
						   

}

BigInteger::BigInteger(const BigInteger&initial){
	nSets = initial.nSets;
	for( int i = 0 ; i < nSets ; ++i ){
		numberSets[ i ] = initial.numberSets[ i ];
	}
}       

BigInteger::~BigInteger(){
}

BigInteger::AbsCmp(const BigInteger&bigInt ){
	int greater = EQUAL;
	int nMax = max( nSets, bigInt.nSets );
	for( int i = nMax - 1 ; i >= 0 ; ++i ){
		if( numberSets[ i ] < bigInt.numberSets[ i ] ){
			return LESS;
		}
		if( numberSets[ i ] < bigInt.numberSets[ i ] ){
			greater = GREATER;
		}
	}	
	return greater;
}
	
bool BigInteger::operator<(const BigInteger&bigInt) const{
	if( sign < bigInt.sign ){
		return true;
	}
	int cmp = this->AbsCmp( bigInt );
	if( (cmp = LESS && sign == POSITIVE) ||
	    (cmp = GREATER && sign = NEGATIVE) ){
		return true;
	}else{
		return false;
	}
}

const BigInteger::AbsAdd( const BigInteger&bigInt1, const BigInteger&bigInt2 ){
	BigInteger result;
	
	int nMaxSets = max( nSets , bigInt.nSets );       
	for( int i = 0 ; i < nMaxSets ; ++i ){
		result.numberSets[i] = result.numberSets[i] + bigInt1.numberSets[i] + bigInt2.numberSets[i];
		result.numberSets[i+1] = result.numberSets[i] >> expo2;
		result.numberSets[i] = result.numberSets[i] && setMask ;
	}
	if( result.numberSets[ nMaxSets ] != 0 ){
		result.nSets = nMaxSets + 1;
	}else{
		result.nSets = nMaxSets;
	}

	return result;
}

const BigInteger::AbsSub( const BigInteger&bigInt1, const BigInteger&bigInt2 ){
	BigInteger result;	
	int nMaxSets = max( nSets , bigInt.nSets );       
	for( int i = 0 ; i < nMaxSets ; ++i ){
		result.numberSets[i] = result.numberSets[i] + (1 << expo2 ) + bigInt1.numberSets[i] - bigInt2.numberSets[i];
		result.numberSets[i+1] = ( result.numberSets[i] >> expo2 ) - 1 ;
		result.numberSets[i] = result.numberSets[i] && setMask ;
	}
	if( result.numberSets[ nMaxSets ] != 0 ){
		result.nSets = nMaxSets + 1;
	}else{
		result.nSets = nMaxSets;
	}

	return result;	
}
const BigInteger operator-(const BigInteger&bigInt) const{
	BigInteger*result;
	if( sign != bigInt.sign ){
		result = &( AbsAdd( (*this) , bigInt ) );
		result->sign = sign;

	}else if( sign == bigInt.sign ){
		int cmp = this->AbsCmp( bigInt );
		if( cmp == LESS ){//If |this| < |bigInt|
			//=> |result| = |bigInt| - |this|
			//reault.sign = -sign
			result = &( AbsSub( bigInt, *this ) );
			result.sign = -sign;
			
		}else{//If |this| > |bigInt|
			//=> |result| = |this| - |bigInt|
			//   result = sign
			result = &( AbsSub( *this, bigInt ) );
			if( cmp == ZERO ){
				result.sign = ZERO;
			}else{
				result.sign = sign;
			}
		}
	}
	return result;
}

	
const BigInteger operator*(const BigInteger&bigInt) const{
	BigInteger result;
	for( int i = 0 ; i < nSets ; ++i ){
		for( int j = 0 ; j < bigInt.nSets ; ++j ){
			result.numberSets[i+j] += this.numberSets[i] * bigInt.numberSets[j];
			result.numberSets[i+j+1] = result.numberSets[i] >> expo2;
			result.numberSets[i+j] &= setMask;
		}
	}
	if( sign == ZERO || bigInt.sign == ZERO ){
		result.sign = ZERO;
		result.nSets = 1;
	}else{
		result.sign = sign == bigInt.sign ? POSITIVE : NEGATIVE;
		if( result.numberSets[ nSets + bigInt.nSets - 1 ] != 0 ){
			result.nSets = nSets + bigInt.nSets;
		}else{
			result.nSets = nSets + bigInt.nSets - 1;
		}
	}
}

const void shiftLeft(const int n){
	//As the number being shifted, the bits would not always fit in a number set.
	//So some of the bits have to be carried out.
	//Example:(expo2 = n( bit in a set ) = 8               
	//        |00000000|00000000|10111101|10001111|10001100| << 10
	//       =|00000010|11110110|00111110|00110000|00000000|
	//               ^^carryout=2  ^....^remain=6
	// offset = 10 / 8 = 1
	int carryout = n % expo2; 
	int mask = ( 1 << carryout ) - 1;
	//mask = ( 1 << 2 ) -1 = |00000011|
	int remain = expo2 - carryout;
	mask = mask << remain;
	//mask << remain = |11000000|
	int offset = n / expo2;
	for( int i = nSets - 1 + offset ; i >= offset ; ++i ){
		numberSets[ i + offset + 1 ] += ( numberSets[ i ] & mask ) >> remain ;
		numberSets[ i + offset ] = numberSets[ i ] << carryout;
		//|10111101| << carryout = |11110100|
		numberSets[ i ] = numberSets[ i ] << n;
	}
	if( numberSets[ nSets + offset ] != 0 ){
		nSets = nSets + offset + 1;
	}else{
		nSets = nSets + offset;
	}	
}


const void shiftRight(const int n){
	//As the number being shifted, the bits would not always fit in a number set.
	//So some of the bits have to be carried in.
	//Example:(expo2 = n( bit in a set ) = 8               
	//        |00000010|11110110|00111110|00110000|00000000| >> 10
	//       =|00000000|00000000|10111101|10001111|10001100| 
	//                             ^....^tail=6    ^^head=2        
	// offset = 10 / 8 = 1
	int head = n % expo2; 
	int mask = ( 1 << head ) - 1;
	//mask = ( 1 << head ) -1 = |00000011|
	int tail = expo2 - head;
	//mask = mask << tail;
	//mask << remain = |11000000|
	int offset = n / expo2;

	numberSets[ 0 ] = numberSets[ offset ] >> head ;
	if( offset > 0 ){
		numberSets[ offset -1 ] = (numberSets[ offset ] & mask) << tail;
	}

	for( int i = offset + 1 ; i < nSets ; ++i ){
		numberSets[ i - offset ] = numberSets[ i ] >> head ;
		numberSets[ i - offset -1 ] = (numberSets[ i ] & mask) << tail;
		numberSets[ i ] = ((unsign Int ) numberSets[ i ]) >> n;
	}

	if( numberSets[ nSets - offset ] != 0 ){
		nSets = nSets - offset + 1;
	}else{
		nSets = nSets - offset;
	}
}

const BigInteger operator%(const BigInteger&bigInt) const{
	BigInteger divisor(bigInt);
	BigInteger divided( (*this) );
	bigInt.shiftLeft( nSets - bigInt.nSets );
	for( int i = 0 ; i < nSets - bigInt.nSets ; ++ i ){
		if( bigInt < divided ){
			divided -= divisor;
		}
		divisor.shiftRight(1);
	}
	for( int i = bigInt.nSets - 1 ; i >= 0 ; ++i ){
		if( divided.numberSets[ i ] == 0 ){
			divided.nSets = i ;
		}
	}
	return divided;
}		
	
BigInteger& operator*=(int multiplier){
	int carry = 0;
	for( int i = 0 ; i < nSets ; ++i ){
		numberSets[ i ] = numberSets[ i ] * multiplier + carry;
		carry = numberSets[ i ] >> expo2;
		numberSets[ i ] &= setMask;
	}
	if( numberSets[ nSets ] > 0 ){
		nSets = nSets + 1;
	}
	       
}

	
BigInteger& operator/=(int divisor){
	for( int i = nSets - 1 ; i > 0 ; --i ){
		numberSets[ i - 1 ] += ( numberSets[ i ] % divisor ) << expo2;
		numberSets[ i ] /= divisor;
	}
	if( numberSets[ nSets - 1  ] = 0 ){
		nSets = nSets - 1;
	}	
}

BigInteger& operator=(const BigInteger&bigInt){
	for( int i = 0; i < nSets ; ++i ){
		numberSets[ i ] = bigInt.numberSets[ i ];
	}
	sign = bigInt.sign;
	nSets = bigInt.nSets;
}


bool iseven();
bool iszero();

friend std::ostream& operator<<(std::ostream&, const BigInteger&);

bool operator<(const BigInteger&) const;

